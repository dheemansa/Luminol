from datetime import datetime
import logging
from pathlib import Path
import re
import shlex
import subprocess

from ..cli.term_colors import AnsiColors
from ..exceptions.exceptions import WallpaperSetError
from ..utils.path import _expand_path

ERR = AnsiColors.ERROR
RESET = AnsiColors.RESET


def _sanitize_filename(s: str, max_len: int = 40) -> str:
    # NOTE: this function was generated by AI
    """
    Sanitizes a string for use as a filename, replacing invalid characters
    and truncating to a specified maximum length.
    """
    # Replace spaces and other common separators with underscores
    s = re.sub(r"[\s/|&;]+", "_", s)
    # Remove characters that are not alphanumeric, underscore, hyphen, or period
    s = re.sub(r"[^\w\-._]", "", s)
    # Remove leading/trailing underscores
    s = s.strip("_")
    # Truncate to max_len
    return s[:max_len]


def _run_detached_command(
    command: str, log_dir: str | Path | None, use_shell: bool = False
) -> None:
    if not command:
        logging.warning("Received an empty command.")
        return

    command_args_list: list = shlex.split(command)
    logging.debug("Executing command: '%s'", command)

    if not log_dir:
        try:
            if use_shell is False:
                subprocess.Popen(  # pylint: disable=consider-using-with
                    command_args_list, start_new_session=True
                )
            else:
                subprocess.Popen(  # pylint: disable=consider-using-with
                    command, shell=True, start_new_session=True
                )

            logging.debug("Successfully launched '%s' without logging.", command)
        except OSError as e:
            logging.error("Failed to launch '%s': %s", command, e)
        return

    try:
        expanded_log_dir = _expand_path(log_dir)

        expanded_log_dir.mkdir(parents=True, exist_ok=True)
        # Use full command string to create a unique, sanitized log filename
        sanitized_command_name = _sanitize_filename(command)
        log_path = expanded_log_dir / f"{sanitized_command_name}.log"

        # some reload commands might be used multiple time,
        # in order to prevent overwriting
        # using append mode instead of write
        with open(log_path, "a", encoding="utf-8") as log_file:
            log_file.write(
                f"****[Date: {datetime.now().date()}]\
                [Time: {datetime.now().strftime('%H:%M:%S')}]****\n\n"
            )
            log_file.write(f"Command: {command}\n\n")
            log_file.write(f"{'*' * 50}  Logging Started  {'*' * 50}\n\n")
            if use_shell is False:
                subprocess.Popen(  # pylint: disable=consider-using-with
                    command_args_list,
                    stdout=log_file,
                    stderr=subprocess.STDOUT,
                    start_new_session=True,
                )
            else:
                subprocess.Popen(  # pylint: disable=consider-using-with
                    command,
                    shell=True,
                    stdout=log_file,
                    stderr=subprocess.STDOUT,
                    start_new_session=True,
                )

        logging.debug(
            "Successfully launched '%s' with logging to %s", command, log_path
        )

    except OSError as e:
        logging.error("Failed to launch '%s': %s", command, e)

    except (ValueError, subprocess.SubprocessError) as e:
        logging.error(
            "An unexpected error occurred while trying to run '%s': %s", command, e
        )


def _truncate_string(text: str) -> str:
    """
    Truncates a string by keeping the first 30 and last 20 characters,
    inserting an ellipsis in the middle if the string is long enough.
    """
    start_len = 30
    end_len = 20
    ellipsis = "....."

    if len(text) <= start_len + end_len + len(ellipsis):
        return text

    start_str = text[:start_len]
    end_str = text[-end_len:]

    return f"{start_str} {ellipsis} {end_str}"


def apply_wallpaper(
    wallpaper_set_command: str,
    image_path: str | Path,
    log_dir: str | Path | None = None,
) -> None:
    """
    Apply a wallpaper by executing the configured command.

    Replaces `{wallpaper_path}` in the command with the actual image path,
    then launches it.

    Args:
        wallpaper_set_command (str): Command to set wallpaper with `{wallpaper_path}` placeholder.
        image_path (str | Path): Path to the wallpaper image.
        log_dir (str | Path): Path to the log directory

    Raises:
        WallpaperSetError: If the wallpaper command is not found or fails to start.
    """
    final_command = wallpaper_set_command.replace(
        "{wallpaper_path}", f"'{str(image_path)}'"
    )

    logging.debug("Executing wallpaper command: %s", final_command)

    try:
        _run_detached_command(command=final_command, log_dir=log_dir, use_shell=False)
        truncated_command = _truncate_string(final_command)
        logging.info("Wallpaper command executed: %s", truncated_command)

    except Exception as e:
        raise WallpaperSetError(
            f"Failed to launch wallpaper command: {final_command}"
        ) from e


def run_reload_commands(
    reload_commands: list[str],
    use_shell: bool = False,
    log_dir: str | Path | None = None,
) -> None:
    """
    Execute a list of reload commands sequentially.

    Each command is launched as a detached, fire-and-forget process.

    Args:
        reload_commands (list[str]): Commands to execute.
        use_shell (bool): If True, enables shell features (pipes, ||, etc.).
                          Avoid using with untrusted input for security reasons.
    """
    for cmd in reload_commands:
        logging.debug("Running reload command: %s", cmd)
        # Commands are run as detached processes ("fire-and-forget") to prevent
        # blocking commands (like 'waybar') from hanging Luminol.
        try:
            if use_shell:
                _run_detached_command(command=cmd, log_dir=log_dir, use_shell=True)
            else:
                _run_detached_command(command=cmd, log_dir=log_dir, use_shell=False)

        except (OSError, ValueError, subprocess.SubprocessError) as e:
            logging.error(
                "An unexpected error occurred while trying to run '%s': %s", cmd, e
            )

    logging.info("All reload commands executed.")

import logging
import subprocess
import shlex
from pathlib import Path
from datetime import datetime
import re  # Added import
from ..exceptions.exceptions import WallpaperSetError
from ..cli.term_colors import AnsiColors
from ..utils.path import _expand_path

ERR = AnsiColors.ERROR
RESET = AnsiColors.RESET


def _sanitize_filename(s: str, max_len: int = 40) -> str:
    # NOTE: this function was generated by AI
    """
    Sanitizes a string for use as a filename, replacing invalid characters
    and truncating to a specified maximum length.
    """
    # Replace spaces and other common separators with underscores
    s = re.sub(r"[\s/|&;]+", "_", s)
    # Remove any characters that are not alphanumeric, underscore, hyphen, or period
    s = re.sub(r"[^\w\-._]", "", s)
    # Remove leading/trailing underscores
    s = s.strip("_")
    # Truncate to max_len
    return s[:max_len]


def _run_detached_command(
    command: str, log_dir: str | Path | None, use_shell: bool = False
) -> None:
    if not command:
        logging.warning("Received an empty command.")
        return

    command_args_list: list = shlex.split(command)
    logging.info("Executing command: '%s'", command)

    if not log_dir:
        try:
            if use_shell is False:
                subprocess.Popen(command_args_list, start_new_session=True)
            else:
                subprocess.Popen(command, shell=True, start_new_session=True)

            logging.info("Successfully launched '%s' without logging.", command)
        except OSError as e:
            logging.error("Failed to launch '%s': %s", command, e)
        return

    try:
        expanded_log_dir = _expand_path(log_dir)

        expanded_log_dir.mkdir(parents=True, exist_ok=True)
        # Use the full command string to create a unique, sanitized log filename
        sanitized_command_name = _sanitize_filename(command)
        log_path = expanded_log_dir / f"{sanitized_command_name}.log"

        # some reload commands might be used multiple time, in order to prevent overwriting
        # using append mode instead of write
        log_file = open(log_path, "a")

        log_file.write(
            f"****[Date: {datetime.now().date()}][Time: {datetime.now().strftime('%H:%M:%S')}]****\n\n"
        )
        log_file.write(f"Command: {command}\n\n")
        log_file.write(f"{'*' * 50}  Logging Started  {'*' * 50}\n\n")
        if use_shell is False:
            subprocess.Popen(
                command_args_list,
                stdout=log_file,
                stderr=subprocess.STDOUT,
                start_new_session=True,
            )
        else:
            subprocess.Popen(
                command,
                shell=True,
                stdout=log_file,
                stderr=subprocess.STDOUT,
                start_new_session=True,
            )

        # TODO: Verify if closing the file handle here is robust. The Popen'd
        # child process inherits the file descriptor, but closing it in the
        # parent immediately after launch might lead to race conditions or
        # lost output on some platforms.
        log_file.close()

        logging.info("Successfully launched '%s' with logging to %s", command, log_path)
    except OSError as e:
        logging.error("Failed to launch '%s': %s", command, e)
    except Exception as e:
        logging.error(
            "An unexpected error occurred while trying to run '%s': %s", command, e
        )


# HACK improve these functions using async functions might work
def apply_wallpaper(
    wallpaper_set_command: str,
    image_path: str | Path,
    log_dir: str | Path | None = None,
) -> None:
    """
    Apply a wallpaper by executing the configured command.

    Replaces `{wallpaper_path}` in the command with the actual image path,
    then launches it.

    Args:
        wallpaper_set_command (str): Command to set wallpaper with `{wallpaper_path}` placeholder.
        image_path (str | Path): Path to the wallpaper image.
        log_dir (str | Path): Path to the log directory

    Raises:
        WallpaperSetError: If the wallpaper command is not found or fails to start.
    """
    final_command = wallpaper_set_command.replace(
        "{wallpaper_path}", f"'{str(image_path)}'"
    )

    logging.debug("Executing wallpaper command: %s", final_command)

    try:
        _run_detached_command(command=final_command, log_dir=log_dir, use_shell=False)

    except Exception as e:
        raise WallpaperSetError(f"Failed to launch wallpaper command: {e}")


def run_reload_commands(
    reload_commands: list[str],
    use_shell: bool = False,
    log_dir: str | Path | None = None,
) -> None:
    """
    Execute a list of reload commands sequentially.

    Each command is launched as a detached, fire-and-forget process.

    Args:
        reload_commands (list[str]): Commands to execute.
        use_shell (bool): If True, enables shell features (pipes, ||, etc.).
                          Avoid using with untrusted input for security reasons.
    """
    for cmd in reload_commands:
        logging.debug("Running reload command: %s", cmd)
        # Commands are run as detached processes ("fire-and-forget") to prevent
        # blocking commands (like 'waybar') from hanging Luminol.
        try:
            if use_shell:
                _run_detached_command(command=cmd, log_dir=log_dir, use_shell=True)
            else:
                _run_detached_command(command=cmd, log_dir=log_dir, use_shell=False)
        except Exception as e:
            logging.error(
                "An unexpected error occurred while trying to run '%s': %s", cmd, e
            )

    logging.info("All reload commands executed.")

from dataclasses import dataclass, field
import logging
from pathlib import Path
import tomllib
from typing import Any

from ..exceptions import InvalidConfigError
from ..utils.path_utils import _expand_path, get_luminol_dir, _is_file_name
from .validate import validate_application_config, validate_global_config


def load_config(config_file_path: str | Path) -> dict:
    """
    Load the TOML configuration file as a dictionary.

    Args:
        config_file_path: Path to the TOML configuration file

    Returns:
        Dictionary containing the parsed TOML configuration

    Raises:
        FileNotFoundError: If the configuration file doesn't exist
        SystemExit: If TOML syntax is invalid or file cannot be read
    """
    config_file_path = Path(config_file_path)

    if not config_file_path.is_file():
        raise FileNotFoundError(
            f"No {config_file_path.name} found in {config_file_path.parent}"
        )

    try:
        with open(config_file_path, "rb") as config:
            config_toml_data: dict = tomllib.load(config)
            logging.info("Config File Loaded")

        return config_toml_data

    except tomllib.TOMLDecodeError as e:
        logging.error("Invalid TOML syntax in config: %s", e)
        raise SystemExit(1) from e

    except OSError as e:
        logging.error("Cannot read config file %s: %s", config_file_path, e)
        raise SystemExit(1) from e

    except Exception as e:
        logging.error(
            "Unexpected error occurred while loading config from %s: %s",
            config_file_path,
            e,
        )
        raise SystemExit(1) from e


# NOTE: most of the class is generated by AI, needs review
@dataclass
class AppSettings:
    """Settings for a single application, parsed from config."""

    # mandetory options
    output_file: str | Path
    syntax: str
    color_format: str

    remap_colors: bool = False
    colors: dict[str, Any] | None = None
    template: str | Path | None = None

    @classmethod
    def from_dict(cls, data: dict) -> "AppSettings":
        """Create AppSettings instance from dictionary."""

        _output_file = data.get("output-file", "")

        if not _is_file_name(_output_file):
            expanded_output_file = _expand_path(_output_file)
        else:
            expanded_output_file = _output_file  # palette will be only stored in cache

        _template = data.get("template", None)
        if _template is not None:
            if _is_file_name(_template):
                expanded_template_path = get_luminol_dir() / "templates" / _template
            else:
                expanded_template_path = _expand_path(_template)
        else:
            expanded_template_path = None

        return cls(
            output_file=expanded_output_file,
            syntax=data.get("syntax", ""),
            color_format=data.get("color-format", ""),
            remap_colors=data.get("remap-colors", False),
            colors=data.get("colors", None),
            template=expanded_template_path,
        )


@dataclass
class GlobalSettings:
    """Global settings for Luminol."""

    wallpaper_command: str = ""
    reload_commands: list[str] = field(default_factory=list)
    theme_type: str = "auto"
    use_shell: bool = False
    log_output: bool = False
    tty_reload: bool = True
    terminal_color_style: str = "default"

    @classmethod
    def from_dict(cls, data: dict) -> "GlobalSettings":
        """Create GlobalSettings instance from dictionary."""
        return cls(
            wallpaper_command=data.get("wallpaper-command", ""),
            reload_commands=data.get("reload-commands", []),
            theme_type=data.get("theme-type", "auto"),
            use_shell=data.get("use-shell", False),
            log_output=data.get("log-output", False),
            tty_reload=data.get("tty-reload", True),
            terminal_color_style=data.get("terminal-color-style", "default"),
        )


class Config:
    """
    Main configuration object providing access to all Luminol settings.

    Validates, and parses the configuration file, providing
    convenient access to global settings and application configurations.

    Attributes:
        global_settings: GlobalSettings instance with theme-wide settings
        apps: Dictionary of enabled application settings

    Examples:
        >>> config_data = {
        ...     "global": {"theme-type": "dark"},
        ...     "rofi": {"enabled": True, "output-file": "colors.rasi",
        ...              "syntax": "*{{name}: {color};}", "color-format": "hex8"}
        ... }
        >>> config = Config(config_data)
        >>> config.global_settings.theme_type
        'dark'
        >>> 'rofi' in config.enabled_apps
        True
        >>> rofi = config.get_app('rofi')
        >>> rofi.color_format
        'hex8'
    """

    def __init__(self, config_data: dict):
        """
        Validate, initialize and parse the raw config data.

        Args:
            config_data: Dictionary containing the parsed TOML configuration

        Raises:
            InvalidConfigError: If configuration validation fails
        """
        # Parse global settings
        global_data: dict = config_data.get("global", {})
        is_global_valid = validate_global_config(global_data)

        app_data: dict[str, dict] = {
            name: data for name, data in config_data.items() if name != "global"
        }

        is_application_valid = validate_application_config(app_data)

        if not (is_global_valid and is_application_valid):
            raise InvalidConfigError(
                "Luminol configuration is invalid. Please review your settings."
            )

        self.global_settings = GlobalSettings.from_dict(global_data)

        self.apps: dict[str, AppSettings] = {
            name: AppSettings.from_dict(data)
            for name, data in app_data.items()
            if isinstance(data, dict) and data.get("enabled", True)
        }

    @property
    def enabled_apps(self) -> tuple[str, ...]:
        """
        Get list of enabled application names.

        Returns:
            List of application names that are enabled in the configuration

        Examples:
            >>> config.enabled_apps
            ['rofi', 'hyprland', 'waybar']
        """
        return tuple(self.apps.keys())

    def get_app(self, app_name: str) -> AppSettings:
        """
        Get settings for a specific application.

        Args:
            app_name: Name of the application

        Returns:
            AppSettings for the application

        Raises:
            KeyError: If application not found or not enabled

        Examples:
            >>> rofi = config.get_app('rofi')
            >>> rofi.output_file
            PosixPath('/home/user/.config/rofi/colors.rasi')
            >>> config.get_app('disabled_app')  # doctest: +SKIP
            KeyError: "Application 'disabled_app' not found or not enabled"
        """
        if app_name not in self.apps:
            raise KeyError(f"Application '{app_name}' not found or not enabled")
        return self.apps[app_name]
